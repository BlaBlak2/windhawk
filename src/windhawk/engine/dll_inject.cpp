#include "stdafx.h"

#include "dll_inject.h"
#include "functions.h"
#include "logger.h"
#include "storage_manager.h"
#include "var_init_once.h"

extern HINSTANCE g_hDllInst;

namespace {

#define PRE_X32SHELLCODE_ARGS_3_TO_1 \
    "\x58"         /* pop eax   */   \
    "\x59"         /* pop ecx   */   \
    "\x83\xC4\x08" /* add esp,8 */   \
    "\x51"         /* push ecx  */   \
    "\x50"         /* push eax  */

#define PRE_X32SHELLCODE_VIRTUAL_FREE                           \
    "\xFF\x74\x24\x04"         /* push dword ptr ss:[esp+4]  */ \
    "\xE8\x1E\x00\x00\x00"     /* call $+1E                  */ \
    "\x85\xC0"                 /* test eax,eax               */ \
    "\x75\x03"                 /* jne $+3                    */ \
    "\xC2\x04\x00"             /* ret 4                      */ \
    "\x59"                     /* pop ecx                    */ \
    "\x5A"                     /* pop edx                    */ \
    "\x68\x00\x80\x00\x00"     /* push 8000                  */ \
    "\x6A\x00"                 /* push 0                     */ \
    "\xE8\x00\x00\x00\x00"     /* call $                     */ \
    "\x66\x81\x24\x24\x00\xF0" /* and word ptr ss:[esp],F000 */ \
    "\x51"                     /* push ecx                   */ \
    "\xFF\xE0"                 /* jmp eax                    */

// The 32-bit InjectShellcode function from the project in the inject_shellcode
// subfolder.
const BYTE x32APCShellcode[] =
    PRE_X32SHELLCODE_ARGS_3_TO_1 PRE_X32SHELLCODE_VIRTUAL_FREE
    "\x55\x8B\xEC\x81\xEC\x88\x00\x00\x00\x64\xA1\x30\x00\x00\x00\xC7\x45\xB8"
    "\x49\x6E\x6A\x65\xC7\x45\xBC\x63\x74\x49\x6E\x66\xC7\x45\xC0\x69\x74\xC6"
    "\x45\xC2\x00\x8B\x48\x0C\x8B\x41\x14\x83\xC1\x14\xC7\x45\x90\x00\x00\x00"
    "\x00\xC7\x45\x8C\x00\x00\x00\x00\xC7\x45\x88\x00\x00\x00\x00\xC7\x45\xF4"
    "\x00\x00\x00\x00\xC7\x45\xEC\x00\x00\x00\x00\xC7\x45\xFC\x00\x00\x00\x00"
    "\xC7\x45\xE8\x00\x00\x00\x00\xC7\x45\x84\x00\x00\x00\x00\x89\x4D\x80\x89"
    "\x45\xF8\x53\x56\x57\x3B\xC1\x0F\x84\x7A\x03\x00\x00\x8B\x5D\xF4\x8D\x64"
    "\x24\x00\x8B\x70\x28\x33\xC9\x0F\xB7\x50\x24\x8D\xA4\x24\x00\x00\x00\x00"
    "\x0F\xB6\x3E\xC1\xC9\x0D\x80\x3E\x61\x72\x03\x83\xC1\xE0\x81\xC2\xFF\xFF"
    "\x00\x00\x03\xCF\x46\x66\x85\xD2\x75\xE4\x81\xF9\x5B\xBC\x4A\x6A\x0F\x85"
    "\xEB\x00\x00\x00\x8B\x5D\xF8\xC7\x45\x94\x08\x00\x00\x00\x8B\x5B\x10\x8B"
    "\x43\x3C\x8B\x44\x18\x78\x03\xC3\x89\x85\x7C\xFF\xFF\xFF\x8B\x70\x20\x8B"
    "\x78\x24\x03\xF3\x8B\x40\x18\x03\xFB\x89\x45\xF0\x85\xC0\x0F\x84\xB4\x00"
    "\x00\x00\x8B\x16\x03\xD3\x33\xC0\x8A\x0A\xC1\xC8\x0D\x8D\x52\x01\x0F\xBE"
    "\xC9\x03\xC1\x8A\x0A\x84\xC9\x75\xEF\x3D\xA4\x4E\x0E\xEC\x75\x05\x8D\x55"
    "\x90\xEB\x52\x3D\xAA\xFC\x0D\x7C\x75\x05\x8D\x55\x8C\xEB\x46\x3D\xA0\xD5"
    "\xC9\x4D\x75\x05\x8D\x55\x88\xEB\x3A\x3D\xAC\x33\x06\x03\x75\x05\x8D\x55"
    "\xF4\xEB\x2E\x3D\x66\x19\xDA\x75\x75\x05\x8D\x55\xEC\xEB\x22\x3D\xBC\x22"
    "\x0D\x47\x75\x05\x8D\x55\xFC\xEB\x16\x3D\xFB\x97\xFD\x0F\x75\x05\x8D\x55"
    "\xE8\xEB\x0A\x3D\x7C\xC4\x22\x59\x75\x27\x8D\x55\x84\x8B\x85\x7C\xFF\xFF"
    "\xFF\x0F\xB7\x0F\x8B\x40\x1C\x8D\x04\x88\x8B\x4D\x94\x8B\x04\x18\x03\xC3"
    "\x81\xC1\xFF\xFF\x00\x00\x89\x02\x89\x4D\x94\xEB\x03\x8B\x4D\x94\x8B\x45"
    "\xF0\x83\xC6\x04\x48\x83\xC7\x02\x89\x45\xF0\x66\x85\xC9\x0F\x85\x44\xFF"
    "\xFF\xFF\x8B\x5D\xF4\x83\x7D\x90\x00\x74\x29\x83\x7D\x8C\x00\x74\x23\x83"
    "\x7D\x88\x00\x74\x1D\x85\xDB\x74\x19\x83\x7D\xEC\x00\x74\x13\x83\x7D\xFC"
    "\x00\x74\x0D\x83\x7D\xE8\x00\x74\x07\x8B\x45\x84\x85\xC0\x75\x1D\x8B\x45"
    "\xF8\x8B\x00\x89\x45\xF8\x3B\x45\x80\x0F\x85\x9D\xFE\xFF\xFF\x8B\x45\xF4"
    "\x5F\x5E\x5B\x8B\xE5\x5D\xC2\x04\x00\x8B\x4D\x08\x33\xFF\xC7\x45\xF8\x00"
    "\x00\x00\x00\x33\xDB\x8B\x31\x8D\x8D\x78\xFF\xFF\xFF\x51\x6A\x01\xFF\xD0"
    "\x83\xFE\x02\x7C\x18\x8D\x45\xDC\xC7\x45\xDC\x5B\x57\x48\x5D\x50\xC7\x45"
    "\xE0\x20\x4C\x4C\x0A\x88\x5D\xE4\xFF\x55\xFC\x8B\x45\x08\x83\xC0\x20\x50"
    "\xFF\x55\x90\x89\x45\xF0\x85\xC0\x0F\x84\xB5\x00\x00\x00\x83\xFE\x02\x7C"
    "\x1E\x8D\x45\xC4\xC7\x45\xC4\x5B\x57\x48\x5D\x50\xC7\x45\xC8\x20\x47\x50"
    "\x41\x66\xC7\x45\xCC\x0A\x00\xFF\x55\xFC\x8B\x45\xF0\x8D\x4D\xB8\x51\x50"
    "\xFF\x55\x8C\x89\x45\x80\x85\xC0\x74\x6E\x83\xFE\x02\x7C\x55\x8D\x45\xD0"
    "\xC7\x45\xD0\x5B\x57\x48\x5D\x50\xC7\x45\xD4\x20\x49\x49\x0A\x88\x5D\xD8"
    "\xFF\x55\xFC\xFF\x75\x08\xC7\x45\xF8\x01\x00\x00\x00\xFF\x55\x80\x8B\xF8"
    "\xC7\x45\xAC\x5B\x57\x48\x5D\x83\xC4\x04\xC7\x45\xB0\x20\x49\x49\x3A\x85"
    "\xFF\xC6\x45\xB4\x20\x66\xC7\x45\xB6\x0A\x00\x0F\x95\xC0\x04\x30\x88\x45"
    "\xB5\x8D\x45\xAC\x50\xFF\x55\xFC\xEB\x19\x8B\x4D\x08\x51\xC7\x45\xF8\x01"
    "\x00\x00\x00\xFF\xD0\x83\xC4\x04\x8B\xF8\xEB\x05\xFF\x55\xEC\x8B\xD8\xFF"
    "\x75\xF0\xFF\x55\x88\x85\xFF\x0F\x85\xF9\x00\x00\x00\xEB\x05\xFF\x55\xEC"
    "\x8B\xD8\x8B\x7D\x08\x8B\x47\x18\x85\xC0\x74\x04\x50\xFF\x55\xE8\xFF\x77"
    "\x10\xFF\x55\xE8\x83\x7D\xF8\x00\x0F\x85\xD4\x00\x00\x00\x83\xFE\x01\x0F"
    "\x8C\xCB\x00\x00\x00\x8B\xCB\xC7\x45\x98\x5B\x57\x48\x5D\x83\xE1\x0F\xC7"
    "\x45\x9C\x20\x45\x52\x52\x83\xF9\x0A\x66\xC7\x45\xA0\x3A\x20\x66\xC7\x45"
    "\xAA\x0A\x00\x1A\xC0\x80\xC1\x37\x24\xF9\xC1\xEB\x04\x02\xC1\x8B\xCB\x88"
    "\x45\xA9\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02"
    "\xC1\x8B\xCB\x88\x45\xA8\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24"
    "\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\xA7\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0"
    "\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\xA6\x83\xE1\x0F\x83"
    "\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\xA5"
    "\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B"
    "\xCB\x88\x45\xA4\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\x80\xC1\x37\x24\xF9\xC1"
    "\xEB\x04\x02\xC1\x83\xFB\x0A\x88\x45\xA3\x1A\xC0\x24\xF9\x04\x37\x02\xC3"
    "\x88\x45\xA2\x8D\x45\x98\x50\xFF\x55\xFC\x6A\x00\xFF\xB5\x78\xFF\xFF\xFF"
    "\xFF\x55\x84\x8B\x45\xF4\x5F\x5E\x5B\x8B\xE5\x5D\xC2\x04\x00";

constexpr SIZE_T x32APCShellcodeSize = sizeof(x32APCShellcode) - 1;

const BYTE* x32Shellcode =
    x32APCShellcode + sizeof(PRE_X32SHELLCODE_ARGS_3_TO_1) - 1;
constexpr SIZE_T x32ShellcodeSize =
    (sizeof(x32APCShellcode) - 1) - (sizeof(PRE_X32SHELLCODE_ARGS_3_TO_1) - 1);

#define PRE_X64SHELLCODE_VIRTUAL_FREE                             \
    "\x48\x83\xEC\x28"             /* sub rsp,28               */ \
    "\xE8\x20\x00\x00\x00"         /* call $+20                */ \
    "\x48\x83\xC4\x28"             /* add rsp,28               */ \
    "\x48\x85\xC0"                 /* test rax,rax             */ \
    "\x75\x01"                     /* jne $+1                  */ \
    "\xC3"                         /* ret                      */ \
    "\x48\x8D\x0D\x00\x00\x00\x00" /* lea rcx,qword ptr ds:[$] */ \
    "\x66\x81\xE1\x00\xF0"         /* and cx,F000              */ \
    "\x33\xD2"                     /* xor edx,edx              */ \
    "\x41\xB8\x00\x80\x00\x00"     /* mov r8d,8000             */ \
    "\xFF\xE0"                     /* jmp rax                  */

// The 64-bit InjectShellcode function from the project in the inject_shellcode
// subfolder.
const BYTE x64Shellcode[] = PRE_X64SHELLCODE_VIRTUAL_FREE
    "\x48\x89\x4C\x24\x08\x55\x53\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48"
    "\x8D\x6C\x24\xE1\x48\x81\xEC\xD8\x00\x00\x00\x45\x33\xF6\xC7\x45\x97\x49"
    "\x6E\x6A\x65\xC7\x45\x9B\x63\x74\x49\x6E\x66\xC7\x45\x9F\x69\x74\xC6\x45"
    "\xA1\x00\x65\x48\x8B\x04\x25\x60\x00\x00\x00\x4C\x89\x75\xD7\x4C\x8B\x65"
    "\xD7\x4C\x89\x75\xF7\x48\x8B\x70\x18\x48\x83\xC6\x20\x4C\x89\x75\xDF\x4C"
    "\x89\x75\x7F\x4C\x89\x75\xCF\x4C\x89\x75\xEF\x48\x8B\x3E\x4C\x89\x75\xE7"
    "\x4C\x89\x75\x77\x4C\x89\x75\xFF\x48\x89\x75\x07\x48\x89\x7D\x0F\x48\x3B"
    "\xFE\x0F\x84\xDA\x03\x00\x00\x4C\x8B\x7D\xDF\x4C\x8B\x6D\xE7\x4C\x8B\x55"
    "\x77\x4C\x8B\x5D\x7F\x48\x8B\x5D\xCF\x0F\x1F\x80\x00\x00\x00\x00\x4C\x8B"
    "\x47\x50\x49\x8B\xC6\x44\x0F\xB7\x4F\x48\xBE\xFF\xFF\x00\x00\x0F\x1F\x40"
    "\x00\x66\x66\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\x41\x0F\xB6\x08\x4D\x8D"
    "\x40\x01\xC1\xC8\x0D\x8B\xD0\x48\x03\xD1\x80\xF9\x61\x48\x8D\x42\xE0\x48"
    "\x0F\x42\xC2\x66\x44\x03\xCE\x75\xDF\x48\x8B\x75\x07\x3D\x5B\xBC\x4A\x6A"
    "\x0F\x85\x17\x01\x00\x00\x4C\x8B\x4F\x20\xBF\x08\x00\x00\x00\x49\x63\x41"
    "\x3C\x42\x8B\xB4\x08\x88\x00\x00\x00\x49\x03\xF1\x44\x8B\x56\x20\x44\x8B"
    "\x5E\x24\x4D\x03\xD1\x8B\x5E\x18\x4D\x03\xD9\x0F\x1F\x80\x00\x00\x00\x00"
    "\x85\xDB\x0F\x84\xBF\x00\x00\x00\x41\x8B\x12\x41\x8B\xC6\x49\x03\xD1\x0F"
    "\xB6\x0A\x0F\x1F\x40\x00\x0F\x1F\x84\x00\x00\x00\x00\x00\xC1\xC8\x0D\x48"
    "\x8D\x52\x01\x0F\xBE\xC9\x03\xC1\x0F\xB6\x0A\x84\xC9\x75\xED\x3D\xA4\x4E"
    "\x0E\xEC\x75\x06\x4C\x8D\x45\xDF\xEB\x59\x3D\xAA\xFC\x0D\x7C\x75\x06\x4C"
    "\x8D\x45\x7F\xEB\x4C\x3D\xA0\xD5\xC9\x4D\x75\x06\x4C\x8D\x45\xCF\xEB\x3F"
    "\x3D\xAC\x33\x06\x03\x75\x06\x4C\x8D\x45\xD7\xEB\x32\x3D\x66\x19\xDA\x75"
    "\x75\x06\x4C\x8D\x45\xEF\xEB\x25\x3D\xBC\x22\x0D\x47\x75\x06\x4C\x8D\x45"
    "\xE7\xEB\x18\x3D\xFB\x97\xFD\x0F\x75\x06\x4C\x8D\x45\x77\xEB\x0B\x3D\x7C"
    "\xC4\x22\x59\x75\x1F\x4C\x8D\x45\xFF\x8B\x4E\x1C\x41\x0F\xB7\x13\x49\x03"
    "\xC9\x8B\x04\x91\x49\x03\xC1\x49\x89\x00\xB8\xFF\xFF\x00\x00\x66\x03\xF8"
    "\x49\x83\xC2\x04\x49\x83\xC3\x02\xFF\xCB\x66\x85\xFF\x0F\x85\x39\xFF\xFF"
    "\xFF\x4C\x8B\x7D\xDF\x4C\x8B\x65\xD7\x4C\x8B\x6D\xE7\x4C\x8B\x55\x77\x4C"
    "\x8B\x5D\x7F\x48\x8B\x5D\xCF\x48\x8B\x7D\x0F\x48\x8B\x75\x07\x4D\x85\xFF"
    "\x74\x2E\x4D\x85\xDB\x74\x29\x48\x85\xDB\x74\x24\x4D\x85\xE4\x74\x1F\x4C"
    "\x8B\x75\xEF\x4D\x85\xF6\x74\x13\x4D\x85\xED\x74\x0E\x4D\x85\xD2\x74\x09"
    "\x48\x8B\x45\xFF\x48\x85\xC0\x75\x18\x45\x33\xF6\x48\x8B\x3F\x48\x89\x7D"
    "\x0F\x48\x3B\xFE\x0F\x85\x56\xFE\xFF\xFF\xE9\x10\x02\x00\x00\x48\x8B\x4D"
    "\x67\x48\x8D\x55\x6F\x8B\x39\x33\xC9\x8B\xF1\x8B\xD9\xB9\x01\x00\x00\x00"
    "\xFF\xD0\x83\xFF\x02\x7C\x1C\x48\x8D\x4C\x24\x20\xC7\x44\x24\x20\x5B\x57"
    "\x48\x5D\xC7\x44\x24\x24\x20\x4C\x4C\x0A\x88\x5C\x24\x28\x41\xFF\xD5\x48"
    "\x8B\x4D\x67\x48\x83\xC1\x20\x41\xFF\xD7\x4C\x8B\xF8\x48\x85\xC0\x0F\x84"
    "\xB5\x00\x00\x00\x83\xFF\x02\x7C\x1B\x48\x8D\x4D\x87\xC7\x45\x87\x5B\x57"
    "\x48\x5D\xC7\x45\x8B\x20\x47\x50\x41\x66\xC7\x45\x8F\x0A\x00\x41\xFF\xD5"
    "\x48\x8D\x55\x97\x49\x8B\xCF\xFF\x55\x7F\x4C\x8B\xF0\x48\x85\xC0\x74\x6E"
    "\x83\xFF\x02\x7C\x57\x48\x8D\x4C\x24\x30\xC7\x44\x24\x30\x5B\x57\x48\x5D"
    "\xC7\x44\x24\x34\x20\x49\x49\x0A\x88\x5C\x24\x38\x41\xFF\xD5\x48\x8B\x4D"
    "\x67\xC7\x45\xF7\x01\x00\x00\x00\x41\xFF\xD6\x85\xC0\xC7\x45\xA7\x5B\x57"
    "\x48\x5D\x8B\xF0\xC7\x45\xAB\x20\x49\x49\x3A\x0F\x95\xC0\xC6\x45\xAF\x20"
    "\x04\x30\x66\xC7\x45\xB1\x0A\x00\x48\x8D\x4D\xA7\x88\x45\xB0\x41\xFF\xD5"
    "\xEB\x17\x48\x8B\x4D\x67\xC7\x45\xF7\x01\x00\x00\x00\x41\xFF\xD6\x8B\xF0"
    "\xEB\x05\xFF\x55\xEF\x8B\xD8\x49\x8B\xCF\xFF\x55\xCF\x85\xF6\x0F\x85\x06"
    "\x01\x00\x00\xEB\x05\x41\xFF\xD6\x8B\xD8\x48\x8B\x75\x67\x48\x8B\x4E\x18"
    "\x48\x85\xC9\x74\x03\xFF\x55\x77\x48\x8B\x4E\x10\xFF\x55\x77\x83\x7D\xF7"
    "\x00\x0F\x85\xDE\x00\x00\x00\x83\xFF\x01\x0F\x8C\xD5\x00\x00\x00\x8B\xCB"
    "\xC7\x45\xB7\x5B\x57\x48\x5D\x83\xE1\x0F\xC7\x45\xBB\x20\x45\x52\x52\x83"
    "\xF9\x0A\x66\xC7\x45\xBF\x3A\x20\xBA\x30\x00\x00\x00\x66\xC7\x45\xC9\x0A"
    "\x00\x41\xB8\x37\x00\x00\x00\x8B\xC2\x41\x0F\x43\xC0\xC1\xEB\x04\x02\xC1"
    "\x8B\xCB\x83\xE1\x0F\x88\x45\xC8\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1"
    "\xEB\x04\x02\xC1\x8B\xCB\x83\xE1\x0F\x88\x45\xC7\x83\xF9\x0A\x8B\xC2\x41"
    "\x0F\x43\xC0\xC1\xEB\x04\x02\xC1\x8B\xCB\x83\xE1\x0F\x88\x45\xC6\x83\xF9"
    "\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEB\x04\x02\xC1\x8B\xCB\x83\xE1\x0F\x88"
    "\x45\xC5\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEB\x04\x02\xC1\x8B\xCB"
    "\x83\xE1\x0F\x88\x45\xC4\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEB\x04"
    "\x02\xC1\x8B\xCB\x83\xE1\x0F\x88\x45\xC3\x83\xF9\x0A\x8B\xC2\x41\x0F\x43"
    "\xC0\xC1\xEB\x04\x02\xC1\x83\xE3\x0F\x83\xFB\x0A\x88\x45\xC2\x48\x8D\x4D"
    "\xB7\x41\x0F\x43\xD0\x02\xD3\x88\x55\xC1\x41\xFF\xD5\x8B\x4D\x6F\x33\xD2"
    "\xFF\x55\xFF\x49\x8B\xC4\x48\x81\xC4\xD8\x00\x00\x00\x41\x5F\x41\x5E\x41"
    "\x5D\x41\x5C\x5F\x5E\x5B\x5D\xC3";

constexpr SIZE_T x64ShellcodeSize = sizeof(x64Shellcode) - 1;

//
// Reference: https://repnz.github.io/posts/apc/wow64-user-apc/
//
ULONG64 EncodeWow64ApcRoutine(ULONG64 ApcRoutine) {
    return (ULONG64)((-(INT64)ApcRoutine) << 2);
}

//
// Reference: https://repnz.github.io/posts/apc/user-apc/
//
BOOL MyQueueUserAPC(PAPCFUNC pfnAPC,
                    HANDLE hThread,
                    ULONG_PTR dwData,
                    USHORT targetProcessArch) {
#ifndef _WIN64
    if (targetProcessArch == IMAGE_FILE_MACHINE_AMD64) {
        // WOW64 to x64 native, use heaven's gate.
        //
        // "Microsoft added a validation to prevent a programming error:
        // If you try to queue an APC from a 32 bit process to a 64 bit
        // process and you use a 32 bit address, you'll get this status code:
        // [...] STATUS_INVALID_HANDLE"
        // https://repnz.github.io/posts/apc/wow64-user-apc/
        return NtQueueApcThread64(HANDLE_TO_DWORD64(hThread),
                                  PTR_TO_DWORD64(pfnAPC), (DWORD64)dwData, 0,
                                  0);
    }
#endif  // _WIN64

    using NtQueueApcThread_t = DWORD(WINAPI*)(
        IN HANDLE ThreadHandle, IN PVOID ApcDispatchRoutine,
        IN ULONG_PTR SystemArgument1, IN ULONG_PTR SystemArgument2,
        IN ULONG_PTR SystemArgument3);

    GET_PROC_ADDRESS_ONCE(NtQueueApcThread_t, pNtQueueApcThread, L"ntdll.dll",
                          "NtQueueApcThread");

    if (!pNtQueueApcThread) {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return FALSE;
    }

#ifdef _WIN64
    if (targetProcessArch == IMAGE_FILE_MACHINE_I386) {
        // x64 native to WOW64, encode address.
        pfnAPC = (PAPCFUNC)EncodeWow64ApcRoutine((ULONG64)pfnAPC);
    }
#endif  // _WIN64

    NTSTATUS result = pNtQueueApcThread(hThread, pfnAPC, dwData, 0, 0);
    if (result < 0) {
        SetLastError(LsaNtStatusToWinError(result));
        return FALSE;
    }

    return TRUE;
}

USHORT GetProcessArch(HANDLE hProcess) {
    // For now, only IMAGE_FILE_MACHINE_I386 and IMAGE_FILE_MACHINE_AMD64.
    // TODO: Use IsWow64Process2 if available.

#ifndef _WIN64
    SYSTEM_INFO siSystemInfo;
    GetNativeSystemInfo(&siSystemInfo);
    if (siSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        // 32-bit machine, only one option.
        return IMAGE_FILE_MACHINE_I386;
    }
#endif  // _WIN64

    BOOL bIsWow64Process;
    if (IsWow64Process(hProcess, &bIsWow64Process) && bIsWow64Process) {
        return IMAGE_FILE_MACHINE_I386;
    }

    return IMAGE_FILE_MACHINE_AMD64;
}

}  // namespace

namespace DllInject {

void DllInject(HANDLE hProcess,
               HANDLE hThreadForAPC,
               HANDLE hSessionManagerProcess,
               HANDLE hSessionMutex,
               bool threadAttachExempt) {
    const BYTE* shellcode;
    size_t shellcodeSize;

    USHORT targetProcessArch = GetProcessArch(hProcess);
    switch (targetProcessArch) {
        case IMAGE_FILE_MACHINE_I386:
            if (hThreadForAPC) {
                // The calling convention is different - three arguments instead
                // of one.
                shellcode = x32APCShellcode;
                shellcodeSize = x32APCShellcodeSize;
            } else {
                shellcode = x32Shellcode;
                shellcodeSize = x32ShellcodeSize;
            }
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            shellcode = x64Shellcode;
            shellcodeSize = x64ShellcodeSize;
            break;

        default:
            throw std::logic_error("Invalid architecture value");
    }

    std::wstring dllPath =
        StorageManager::GetInstance().GetEnginePath(targetProcessArch) /
        L"windhawk.dll";
    size_t dllPathBytes = (dllPath.length() + 1) * sizeof(WCHAR);

    HANDLE hRemoteSessionManagerProcess;
    THROW_IF_WIN32_BOOL_FALSE(DuplicateHandle(
        GetCurrentProcess(), hSessionManagerProcess, hProcess,
        &hRemoteSessionManagerProcess,
        PROCESS_DUP_HANDLE | PROCESS_QUERY_LIMITED_INFORMATION | SYNCHRONIZE,
        FALSE, 0));

    auto remoteSessionManagerProcessCleanup =
        wil::scope_exit([hProcess, hRemoteSessionManagerProcess] {
            DuplicateHandle(hProcess, hRemoteSessionManagerProcess, nullptr,
                            nullptr, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
        });

    HANDLE hRemoteSessionMutex = nullptr;
    if (hSessionMutex) {
        THROW_IF_WIN32_BOOL_FALSE(DuplicateHandle(
            GetCurrentProcess(), hSessionMutex, hProcess, &hRemoteSessionMutex,
            PROCESS_QUERY_LIMITED_INFORMATION, FALSE, 0));
    }

    auto remoteSessionMutexCleanup =
        wil::scope_exit([hProcess, hRemoteSessionMutex] {
            if (hRemoteSessionMutex) {
                DuplicateHandle(hProcess, hRemoteSessionMutex, nullptr, nullptr,
                                0, FALSE, DUPLICATE_CLOSE_SOURCE);
            }
        });

    size_t shellcodeDataSize =
        offsetof(LOAD_LIBRARY_REMOTE_DATA, szDllName) + dllPathBytes;
    auto shellcodeDataVector = std::vector<BYTE>(shellcodeDataSize);
    auto shellcodeData =
        reinterpret_cast<LOAD_LIBRARY_REMOTE_DATA*>(shellcodeDataVector.data());

    shellcodeData->nLogVerbosity =
        static_cast<INT32>(Logger::GetInstance().GetVerbosity());
    shellcodeData->bRunningFromAPC = !!hThreadForAPC;
    shellcodeData->bThreadAttachExempt = threadAttachExempt;
    shellcodeData->hSessionManagerProcess = hRemoteSessionManagerProcess;
    shellcodeData->hSessionMutex = hRemoteSessionMutex;
    memcpy(shellcodeData->szDllName, dllPath.c_str(), dllPathBytes);

    size_t shellcodeSizeAligned =
        (shellcodeSize + (sizeof(LONG_PTR) - 1)) & ~(sizeof(LONG_PTR) - 1);

    // Allocate enough memory in the remote process's address space
    // to hold the shellcode and the data struct.
    void* pRemoteCode = VirtualAllocEx(
        hProcess, nullptr, shellcodeSizeAligned + shellcodeDataSize,
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    THROW_LAST_ERROR_IF_NULL(pRemoteCode);

    auto remoteCodeCleanup = wil::scope_exit([hProcess, pRemoteCode] {
        VirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
    });

    // Write our shellcode into the remote process.
    THROW_IF_WIN32_BOOL_FALSE(WriteProcessMemory(
        hProcess, pRemoteCode, shellcode, shellcodeSize, nullptr));

    // Write a copy of our struct to the remote process.
    void* pRemoteData =
        reinterpret_cast<BYTE*>(pRemoteCode) + shellcodeSizeAligned;
    THROW_IF_WIN32_BOOL_FALSE(WriteProcessMemory(
        hProcess, pRemoteData, shellcodeData, shellcodeDataSize, nullptr));

    // Mark shellcode as executable.
    DWORD oldProtect;
    THROW_IF_WIN32_BOOL_FALSE(VirtualProtectEx(
        hProcess, pRemoteCode, shellcodeSize, PAGE_EXECUTE_READ, &oldProtect));

    if (hThreadForAPC) {
        THROW_IF_WIN32_BOOL_FALSE(MyQueueUserAPC(
            reinterpret_cast<PAPCFUNC>(pRemoteCode), hThreadForAPC,
            reinterpret_cast<ULONG_PTR>(pRemoteData), targetProcessArch));
#ifndef _WIN64
    } else if (targetProcessArch == IMAGE_FILE_MACHINE_AMD64) {
        // WOW64 to x64 native, use heaven's gate.
        wil::unique_process_handle remoteThread((HANDLE)CreateRemoteThread64(
            HANDLE_TO_DWORD64(hProcess), PTR_TO_DWORD64(pRemoteCode),
            PTR_TO_DWORD64(pRemoteData),
            threadAttachExempt
                ? Functions::MY_REMOTE_THREAD_THREAD_ATTACH_EXEMPT
                : 0));
        THROW_LAST_ERROR_IF_NULL(remoteThread);
#endif  // _WIN64
    } else {
        wil::unique_process_handle remoteThread(Functions::MyCreateRemoteThread(
            hProcess, reinterpret_cast<LPTHREAD_START_ROUTINE>(pRemoteCode),
            pRemoteData,
            threadAttachExempt
                ? Functions::MY_REMOTE_THREAD_THREAD_ATTACH_EXEMPT
                : 0));
        THROW_LAST_ERROR_IF_NULL(remoteThread);
    }

    remoteSessionManagerProcessCleanup.release();
    remoteSessionMutexCleanup.release();
    remoteCodeCleanup.release();
}

}  // namespace DllInject
